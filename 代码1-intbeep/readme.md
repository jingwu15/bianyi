### 用GCC生成ARM祼机代码

```
机器指令就是二进制码，如果要机器按我们的要求执行，就要提供给机器需要的二进制码。
在写编译器之前，一定要弄清楚ARM祼机的代码是如何用C语言存储与生成的。
这样我们就可以写出我们自已汇编器与编译器。
```

#### 1. 什么样的数据结构适合存储ARM机器码
```
因为我们用的是32位的ARM板子，指令集是定长32位的，正好与整数类型的长度一致，故可用整数数组来存储ARM机器码。
```

#### 2. 整数数组写入文件后能否与二进制代码对应
```
ARM祼机代码：
od -w4 -tx2 -v beep.bin 
0000000 1014 e59f
0000004 0000 e591
0000010 000f e3c0
0000014 0002 e380
0000020 0000 e581
0000024 fffe eaff
0000030 fffe eaff
0000034 00a0 1140
0000040

通过ARM机器码构造整数数组：
int rows[] = {
    0x1014e59f,
    0x0000e591,
    0x000fe3c0,
    0x0002e380,
    0x0000e581,
    0xfffeeaff,
    0xfffeeaff,
    0x00a01140
};

写入文件后的二进制如下：
od -w4 -tx2 -v arm-beep.bin 
0000000 e59f 1014
0000004 e591 0000
0000010 e3c0 000f
0000014 e380 0002
0000020 e581 0000
0000024 eaff fffe
0000030 eaff fffe
0000034 1140 00a0
0000040

我们发现数据不对应，二进制的前后16位颠倒了，由此我们发现了ARM机器码与整数的对应关系。
```

#### ARM机器码与整数的对应关系
```
32位的机器码与32位的整数，都用16进制表示后，颠倒前后16位可相互转换。


ARM祼机代码：
0000000 1014 e59f
0000004 0000 e591
0000010 000f e3c0
0000014 0002 e380
0000020 0000 e581
0000024 fffe eaff
0000030 fffe eaff
0000034 00a0 1140
0000040

整型数组：
int rows[] = {
    0xe59f1014,
    0xe5910000,
    0xe3c0000f,
    0xe3800002,
    0xe5810000,
    0xeafffffe,
    0xeafffffe,
    0x114000a0
};
```


### 代码演示
```
$ make
gcc -m32 wbeep-create.c -o ./bin/wbeep-create.bin
$ ./bin/wbeep-create.bin
ls
arm-beep.bin  bin  Makefile  readme.md  wbeep-create.c

将 arm-beep.bin 传到(kermit) 板子上即可执行
loadb 40008000
CTL+\\+C
send /xx/xxx/xxx/arm-beep.bin
c
go 40008000

之后蜂鸣器就响了
```
